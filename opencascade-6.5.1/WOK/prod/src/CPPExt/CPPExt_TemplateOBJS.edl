-- File:	CPPExt_TemplateOBJS.edl
-- Author:	Kernel
-- History:	Thu Dec 21 08:27:18 1995	Kernel	Creation
-- Copyright:	 Matra Datavision 1995

-- =================================
-- extraction of a persistent handle
-- =================================

@template HandlePersistentOBJS(%HPName,%HPName,%HPInherits) is
$// This file is generated by WOK (CPPExt).
$// Please do not edit this file; modify original file instead.
$// The copyright and license terms as defined for the original file apply to 
$// this header file considered to be the "object code" form of the original source.
$
$#ifndef Handle_%HPName_HeaderFile
$#define Handle_%HPName_HeaderFile
$#define %HPNameType %HPName_Type_()
$
$#ifndef _%HPName_Pointer
$#define _%HPName_Pointer
$class %HPName;
$class Handle_%HPName;
$#ifdef DECOSF1
$#pragma pointer_size save
$#pragma pointer_size short
$#endif
$typedef %HPName* %HPName_ptr;
$typedef Handle_%HPName* Handle_%HPName_ptr;
$#ifdef DECOSF1
$#pragma pointer_size restore
$#endif
$#endif
$
$#ifndef _Handle_%HPInherits_HeaderFile
$#include <Handle_%HPInherits.hxx>
$#endif
$
$class Oid_%HPName;
$class %HPName;
$
$class Handle_%HPName: public Handle_%HPInherits {
$
$public:
$
$ Handle_%HPName();
$ Handle_%HPName(const Handle_%HPName& AnObject);
$ Handle_%HPName(const %HPName_ptr AnObject);
$ Standard_EXPORT ~Handle_%HPName();
$ Handle_%HPName& operator=(const Handle_%HPName& AnObject);
$ Standard_EXPORT Handle_%HPName& operator=(const %HPName_ptr AnObject);
$ Standard_EXPORT static const Handle_%HPName DownCast(const Handle_Standard_Persistent&);
$ Standard_Boolean   operator==(const Handle_%HPName& AnObject) const ;
$ Standard_Boolean operator!=(const Handle_%HPName& AnObject) const;
$ Oid_%HPName* operator->() const;
$};
$
$
$Handle_%HPName::Handle_%HPName()
${
$}
$
$Handle_%HPName::Handle_%HPName(const Handle_%HPName& AnObject) 
$ : Handle_%HPInherits(AnObject)
${
$}
$
$Handle_%HPName::Handle_%HPName(const %HPName_ptr AnObject) 
$ : Handle_%HPInherits((const %HPInherits_ptr)AnObject)
${
$}
$
$Handle_%HPName& Handle_%HPName::operator=(const Handle_%HPName& AnObject) 
${
$  Identifier=AnObject.Identifier; return *this;
$}
$
$Standard_Boolean Handle_%HPName::operator==(const Handle_%HPName& AnObject)const 
${
$  return Identifier==AnObject.Identifier;
$}
$
$Standard_Boolean Handle_%HPName::operator!=(const Handle_%HPName& AnObject)const 
${
$  return Identifier!=AnObject.Identifier;
$}
$
$Oid_%HPName* Handle_%HPName::operator->() const 
${
$  return (Oid_%HPName*)(void*)&(((Handle_%HPName_ptr)this)->Identifier);
$}
$
$#endif
@end;

@template PersistentOBJSInstClass(%Class,
				  %Inherits,
                                  %TICIncludes,
                                  %TICPublicfriends,
                                  %TICOidpubMet,
                                  %TICOidproMet,
                                  %TICOidpriMet,
                                  %TICPublicmets,
                                  %TICPublicfriends,
                                  %TICProtectedmets,
                                  %TICProtectedfields,
                                  %TICPrivatemets,
                                  %TICPrivatefields,
                                  %TICPrivatefriends,
                                  %TICDefines,
                                  %TICInlineIncludes,
                                  %TICUndefines,
                                  %TICSuppMethod) is
$// This file is generated by WOK (CPPExt).
$// Please do not edit this file; modify original file instead.
$// The copyright and license terms as defined for the original file apply to 
$// this header file considered to be the "object code" form of the original source.
$//
$#ifndef _%Class_HeaderFile
$#define _%Class_HeaderFile
$
$#ifndef _%Class_Pointer
$#define _%Class_Pointer
$class %Class;
$class Handle_%Class;
$#ifdef DECOSF1
$#pragma pointer_size save
$#pragma pointer_size short
$#endif
$typedef %Class* %Class_ptr;
$typedef Handle_%Class* Handle_%Class_ptr;
$#ifdef DECOSF1
$#pragma pointer_size restore
$#endif
$#endif
$
$#ifndef _Handle_%Class_HeaderFile
$#include <Handle_%Class.hxx>
$#endif
$
$%TICIncludes
$#ifndef _Standard_ImmutableObject_HeaderFile
$#include <Standard_ImmutableObject.hxx>
$#endif
$
$class Oid_%Class : public Oid_%Inherits {
$
$friend class %Class;
$%TICPublicfriends
$
$public:
$
$%TICOidpubMet 
$Oid_%Class() {};
$~Oid_%Class() {};
$
$protected:
$
$%TICOidproMet
$
$private:
$
$%TICOidpriMet 
$};
$
$#ifdef OBJS
$Standard_EXPORT Handle_%Class_ptr Standard_PersistentAllocation(const Handle_%Class&, Standard_Integer size = 1);
$#endif
$
$class %Class : public %Inherits {
$
$friend class Oid_%Class;
$
$public:
$
$ // Methods PUBLIC
$ // 
$%TICPublicmets
$
$%TICPublicfriends
$
$ // Type management
$ //
$ Standard_EXPORT friend Handle_Standard_Type& %Class_Type_();
$ Standard_EXPORT friend Handle_%Class_ptr Standard_PersistentAllocation(const Handle_%Class&, Standard_Integer size);
$ Standard_EXPORT const Handle(Standard_Type)& DynamicType() const;
$ Standard_EXPORT Standard_Boolean	       IsKind(const Handle(Standard_Type)&) const;
$
$#ifdef OBJS
$Standard_EXPORT void* operator new (size_t) ;
$Standard_EXPORT void* operator new (size_t, Standard_DBHandle);
$Standard_EXPORT void* operator new (size_t, Standard_Container);
$Standard_EXPORT void* operator new (size_t, Handle(Standard_Persistent));
$Standard_EXPORT void  operator delete (void*);
$Standard_EXPORT static os_typespec* get_mdtv_typespec()
$	{
$		static os_typespec* mytypespec = NULL;
$		if (mytypespec == NULL)
$			mytypespec = new os_typespec("%Class");
$		return mytypespec;
$	}
$Standard_EXPORT virtual Standard_Persistent_ptr allocate_emptyObject(Standard_Integer size = 1) const;
$#endif
$
$protected:
$
$ // Methods PROTECTED
$ // 
$%TICProtectedmets
$
$ // Fields PROTECTED
$ //
$%TICProtectedfields
$
$private: 
$
$ // Methods PRIVATE
$ // 
$%TICPrivatemets
$
$ // Fields PRIVATE
$ //
$%TICPrivatefields
$%TICPrivatefriends
$};
$
$%TICDefines
$%TICInlineIncludes
$%TICUndefines
$
$// other Inline functions and methods (like "C++: function call or Oid methods" methods)
$//
$%TICSuppMethod
$
$#endif
@end;

@template PersistentOBJSIxx(%Class,%Suffix,%Supplement,%TypeMgt,%Methods,%Destructor,%MethodOID) is
$// This file is generated by WOK (CPPExt).
$// Please do not edit this file; modify original file instead.
$// The copyright and license terms as defined for the original file apply to 
$// this header file considered to be the "object code" form of the original source.
$//
$#ifndef _Standard_TypeMismatch_HeaderFile
$#include <Standard_TypeMismatch.hxx>
$#endif
$
$%Supplement 
$
$#include <%Class.%Suffix>
$
$%Destructor
$
$%TypeMgt
$
$ Handle_%Class& Handle_%Class::operator=(const %Class_ptr AnObject) 
$ {
$   Identifier = AnObject; 
$   return *this;
$ }
$
$ void* %Class::operator new (size_t ASize) {	
$  return new (Standard_Persistent::PreNew(),%Class::get_mdtv_typespec()) char[(long) ASize] ;
$ }
$
$ // DELETE
$ void %Class::operator delete (void* _AnAddress) { 
$   ::delete _AnAddress; 
$ }
$ // DELETEEND
$
$ void* %Class::operator new (size_t ASize, Standard_DBHandle db) {	
$   return new (db,%Class::get_mdtv_typespec()) char[(long) ASize] ;
$ }
$
$ void* %Class::operator new (size_t ASize, Standard_Container cont) {	
$   return new (cont,%Class::get_mdtv_typespec()) char[(long) ASize] ;
$ }
$
$ void* %Class::operator new (size_t ASize, Handle(Standard_Persistent) hd) {	
$   return new (os_segment::of(hd->GetOId()),%Class::get_mdtv_typespec()) char[(long) ASize] ;
$ }
$
$%MethodOID
$%Methods
@end;

@template ImmutableTestOBJS(%DName,%MethodName) is
$  if (%DName.IsImmutable()) Standard_ImmutableObject::Raise("Immutable object handle in %MethodName");
@end;

@template UpdateAccessOBJS(%Class,%MethodName) is
$ ((%Class_ptr)UpdateAccess())->%MethodName;
@end;

@template ReadAccessOBJS(%Class,%MethodName) is
$ ((%Class_ptr)ReadAccess())->%MethodName;
@end;


@template ItemMDTVDefine(%DName,%DValue) is
$#define %DName %DValue
$#define %DName_hxx <%DValue.hxx>
@end;

@template ItemMDTVptrDefine(%DName,%DValue) is
$#define %DName_ptr %DValue_ptr
@end;

@template ItemMDTVptrUndef(%DName) is
$#undef %DName_ptr
@end;

@template ItemMDTVConstraintHandle(%DName,%DValue) is
$#define Handle_%DName Handle_%DValue
@end;

@template ItemMDTVConstraintHandleUndef(%DName) is
$#undef Handle_%DName
@end;

@template ItemHandleMDTVDefine(%DName,%DValue) is
$#define Handle_%DName Handle_%DValue
$#define %DName_Type_() %DValue_Type_()
$#define %DName_ptr %DValue_ptr
@end;

@template ItemMDTVUndefine(%DName) is
$#undef %DName
$#undef %DName_hxx
@end;

@template ItemHandleMDTVUndefine(%DName) is
$#undef Handle_%DName
$#undef %DName_Type_
@end;

@template IncludeMDTVNoSafe(%IClass,%Suffix) is
$#include <%IClass.%Suffix>
@end;

@template VArrayFieldOBJS(%DName,%DValue) is
$#ifdef OBJS
$DBC_PCLASS_OBJS *myData;
$#endif
@end;

@template VArrayDeclareOBJS(%DName,%DValue) is
$#ifdef OBJS
$#include <ostore/ostore.hh>
$#include <ostore/coll.hh>
$typedef %DValue %DName_%DValue;
$
$class P_%DName {
$public:
$  static os_typespec* get_mdtv_typespec();
$  
$  %DValue myValue;
$};
$#define  P_%DName_use_DBC
$#ifdef DBC_PCLASS_OBJS
$#undef DBC_PCLASS_OBJS
$#endif
$#define DBC_PCLASS_OBJS P_%DName
$#endif
@end;

@template PersistentAllocationOBJS (%Class) is
$Standard_Persistent_ptr %Class::allocate_emptyObject(Standard_Integer size) const {
$ if (size == 1 ) 
$ return new %Class;
$ else 
$ return new(Standard_Persistent::PreNew(), %Class::get_mdtv_typespec(), size) %Class[size]; 
$}
$
$Standard_EXPORT Handle_%Class_ptr Standard_PersistentAllocation(const Handle_%Class& Value, Standard_Integer size) { 
$Handle_%Class_ptr hd;
$ if (size == 1 ) { 
$ hd = new(Standard_Persistent::PreNew(),Handle_%Class::get_mdtv_typespec()) Handle_%Class(Value);
$ } else { 
$ hd = new(Standard_Persistent::PreNew(),Handle_%Class::get_mdtv_typespec(), size) Handle_%Class[size]; 
$} return hd;
$}
$
@end;

@template PersistentAllocationOBJSDeferred (%Class) is
$Standard_Persistent_ptr %Class::allocate_emptyObject(Standard_Integer size) const {
$  Standard_Persistent_ptr dummy = 0L;
$  return dummy;
$}
$
$Standard_EXPORT Handle_%Class_ptr Standard_PersistentAllocation(const Handle_%Class& Value, Standard_Integer size) { 
$ Handle_%Class_ptr hd = 0L;
$ return hd;
$}
$
@end;
