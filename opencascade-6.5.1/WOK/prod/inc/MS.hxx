// This file is generated by WOK (CPPExt).
// Please do not edit this file; modify original file instead.
// The copyright and license terms as defined for the original file apply to 
// this header file considered to be the "object code" form of the original source.

#ifndef _MS_HeaderFile
#define _MS_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

#ifndef _Handle_TCollection_HAsciiString_HeaderFile
#include <Handle_TCollection_HAsciiString.hxx>
#endif
#ifndef _Handle_MS_Method_HeaderFile
#include <Handle_MS_Method.hxx>
#endif
#ifndef _Handle_MS_MetaSchema_HeaderFile
#include <Handle_MS_MetaSchema.hxx>
#endif
#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _Handle_MS_Type_HeaderFile
#include <Handle_MS_Type.hxx>
#endif
#ifndef _Handle_MS_Class_HeaderFile
#include <Handle_MS_Class.hxx>
#endif
#ifndef _Handle_TColStd_HSequenceOfHAsciiString_HeaderFile
#include <Handle_TColStd_HSequenceOfHAsciiString.hxx>
#endif
#ifndef _Handle_MS_Interface_HeaderFile
#include <Handle_MS_Interface.hxx>
#endif
#ifndef _Handle_MS_HSequenceOfExternMet_HeaderFile
#include <Handle_MS_HSequenceOfExternMet.hxx>
#endif
#ifndef _Handle_MS_HSequenceOfMemberMet_HeaderFile
#include <Handle_MS_HSequenceOfMemberMet.hxx>
#endif
#ifndef _Handle_MS_Common_HeaderFile
#include <Handle_MS_Common.hxx>
#endif
#ifndef _Handle_MS_InstClass_HeaderFile
#include <Handle_MS_InstClass.hxx>
#endif
#ifndef _Handle_MS_StdClass_HeaderFile
#include <Handle_MS_StdClass.hxx>
#endif
#ifndef _Handle_MS_MemberMet_HeaderFile
#include <Handle_MS_MemberMet.hxx>
#endif
#ifndef _Handle_MS_Param_HeaderFile
#include <Handle_MS_Param.hxx>
#endif
#ifndef _Handle_MS_Field_HeaderFile
#include <Handle_MS_Field.hxx>
#endif
class TCollection_HAsciiString;
class MS_Method;
class MS_MetaSchema;
class MS_Type;
class MS_Class;
class TColStd_HSequenceOfHAsciiString;
class WOKTools_MapOfHAsciiString;
class MS_Interface;
class MS_HSequenceOfExternMet;
class MS_HSequenceOfMemberMet;
class MS_Common;
class MS_InstClass;
class MS_StdClass;
class MS_MemberMet;
class MS_Param;
class MS_Field;
class MS_ExecFile;
class MS_MetaSchema;
class MS_Common;
class MS_Field;
class MS_Param;
class MS_ParamWithValue;
class MS_GlobalEntity;
class MS_Exec;
class MS_Schema;
class MS_Executable;
class MS_ExecPart;
class MS_Engine;
class MS_Component;
class MS_Interface;
class MS_Client;
class MS_Package;
class MS_Method;
class MS_ExternMet;
class MS_MemberMet;
class MS_Construc;
class MS_ClassMet;
class MS_InstMet;
class MS_Type;
class MS_GenType;
class MS_NatType;
class MS_Alias;
class MS_Pointer;
class MS_Enum;
class MS_Imported;
class MS_PrimType;
class MS_Class;
class MS_GenClass;
class MS_InstClass;
class MS_StdClass;
class MS_Error;
class MS_MapOfType;
class MS_MapOfGlobalEntity;
class MS_MapOfMethod;
class MS_SequenceOfType;
class MS_SequenceOfGenType;
class MS_SequenceOfExternMet;
class MS_SequenceOfMethod;
class MS_SequenceOfMemberMet;
class MS_SequenceOfField;
class MS_SequenceOfParam;
class MS_Array1OfParam;
class MS_SequenceOfClass;
class MS_SequenceOfError;
class MS_SequenceOfPackage;
class MS_SequenceOfInstClass;
class MS_SequenceOfGenClass;
class MS_SequenceOfGlobalEntity;
class MS_SequenceOfInterface;
class MS_SequenceOfSchema;
class MS_SequenceOfEngine;
class MS_SequenceOfComponent;
class MS_SequenceOfExecutable;
class MS_HSequenceOfType;
class MS_HSequenceOfGenType;
class MS_HSequenceOfExternMet;
class MS_HSequenceOfMethod;
class MS_HSequenceOfMemberMet;
class MS_HSequenceOfField;
class MS_HSequenceOfParam;
class MS_HArray1OfParam;
class MS_HSequenceOfClass;
class MS_HSequenceOfError;
class MS_HSequenceOfPackage;
class MS_HSequenceOfInstClass;
class MS_HSequenceOfGenClass;
class MS_HSequenceOfGlobalEntity;
class MS_HSequenceOfInterface;
class MS_HSequenceOfSchema;
class MS_HSequenceOfEngine;
class MS_HSequenceOfComponent;
class MS_HSequenceOfExecutable;
class MS_SequenceOfExecFile;
class MS_HSequenceOfExecFile;
class MS_SequenceOfExecPart;
class MS_HSequenceOfExecPart;
class MS_DataMapIteratorOfMapOfType;
class MS_DataMapIteratorOfMapOfGlobalEntity;
class MS_DataMapIteratorOfMapOfMethod;
class MS_SequenceNodeOfSequenceOfType;
class MS_SequenceNodeOfSequenceOfGenType;
class MS_SequenceNodeOfSequenceOfExternMet;
class MS_SequenceNodeOfSequenceOfMethod;
class MS_SequenceNodeOfSequenceOfMemberMet;
class MS_SequenceNodeOfSequenceOfField;
class MS_SequenceNodeOfSequenceOfParam;
class MS_SequenceNodeOfSequenceOfClass;
class MS_SequenceNodeOfSequenceOfError;
class MS_SequenceNodeOfSequenceOfPackage;
class MS_SequenceNodeOfSequenceOfInstClass;
class MS_SequenceNodeOfSequenceOfGenClass;
class MS_SequenceNodeOfSequenceOfGlobalEntity;
class MS_SequenceNodeOfSequenceOfInterface;
class MS_SequenceNodeOfSequenceOfSchema;
class MS_SequenceNodeOfSequenceOfEngine;
class MS_SequenceNodeOfSequenceOfComponent;
class MS_SequenceNodeOfSequenceOfExecutable;
class MS_SequenceNodeOfSequenceOfExecFile;
class MS_SequenceNodeOfSequenceOfExecPart;


//! Meta Schema Package for MDTV Dev. Tools. <br>
//! <br>
class MS  {
public:

  void* operator new(size_t,void* anAddress) 
  {
    return anAddress;
  }
  void* operator new(size_t size) 
  {
    return Standard::Allocate(size); 
  }
  void  operator delete(void *anAddress) 
  {
    if (anAddress) Standard::Free((Standard_Address&)anAddress); 
  }

  
  Standard_EXPORT   static  Handle_TCollection_HAsciiString GetPersistentRootName() ;
  
  Standard_EXPORT   static  Handle_TCollection_HAsciiString GetStorableRootName() ;
  
  Standard_EXPORT   static  Handle_TCollection_HAsciiString GetTransientRootName() ;
  
  Standard_EXPORT   static  Handle_TCollection_HAsciiString GetPackageRootName() ;
  //! Warning this method is obsolete <br>
  Standard_EXPORT   static  Handle_TCollection_HAsciiString GetVArrayRootName() ;
  //! build a full name from a global entity name and an entity name <br>
  Standard_EXPORT   static  Handle_TCollection_HAsciiString BuildFullName(const Handle(TCollection_HAsciiString)& aGEName,const Handle(TCollection_HAsciiString)& aEName) ;
  //! build a complex name for nested classes <br>
//!          <MyName> : the name of the containing class <br>
//!          <aEName> : the name of the nested class <br>
//!          <aGEName> : the name of the generic class <br>
  Standard_EXPORT   static  Handle_TCollection_HAsciiString BuildComplexName(const Handle(TCollection_HAsciiString)& MyName,const Handle(TCollection_HAsciiString)& aEName,const Handle(TCollection_HAsciiString)& aGEName) ;
  
  Standard_EXPORT   static  Handle_TCollection_HAsciiString GetEntityNameFromMethodName(const Handle(TCollection_HAsciiString)& methodName) ;
  //! find a method with a short name. <br>
//!          short names are those that comes from the interface or friend method's list <br>
  Standard_EXPORT   static  Handle_MS_Method GetMethodFromFriendName(const Handle(MS_MetaSchema)& aMeta,const Handle(TCollection_HAsciiString)& methodName) ;
  //! Checks if a basic type is exportable (used by IsExportableMethod and IsExportableClass). <br>
  Standard_EXPORT   static  Standard_Boolean IsExportedType(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Type)& aType) ;
  //! for interface, engine or stubs extractor some types cannot be exported like pointer or imported <br>
//!          so this function returns False if one of these type is used by the method <aMethod> <br>
  Standard_EXPORT   static  Standard_Boolean IsExportableMethod(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Method)& aMethod) ;
  //! as <IsExportableMethod>, but this method checks if the class is not generic and checks methods. <br>
//!          If <mustCheckField> == Standard_True -> fields are checked. <br>
//!          If <mustCheckMethods> == Standard_True -> methods are checked. <br>
  Standard_EXPORT   static  Standard_Boolean IsExportableClass(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Class)& aClass,const Standard_Boolean mustCheckField,const Standard_Boolean mustCheckMethods) ;
  //! we test the type and dispatch it in the different lists <br>
//!          <aFullList>      : list of all the type used <br>
//!          <aList>          : list of complete types used <br>
//!          <aIncp>          : list of incomplete types used <br>
//!          <notusedwithref> : type are assumed to be used with reference if TRUE <br>
  Standard_EXPORT   static  void DispatchUsedType(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Type)& aType,const Handle(TColStd_HSequenceOfHAsciiString)& aList,const Handle(TColStd_HSequenceOfHAsciiString)& aIncList,const Standard_Boolean notusedwithref) ;
  //! sort the method used types : <br>
//!          <aFullList>      : list of all the type used <br>
//!          <aList>          : list of complete types used <br>
//!          <aIncp>          : list of incomplete types used <br>
  Standard_EXPORT   static  void MethodUsedTypes(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Method)& aMethod,const Handle(TColStd_HSequenceOfHAsciiString)& aList,const Handle(TColStd_HSequenceOfHAsciiString)& aIncList) ;
  //! sort the class used types : <br>
//!          <aFullList>      : list of all the type used <br>
//!          <aList>          : list of complete types used <br>
//!          <aIncp>          : list of incomplete types used <br>
  Standard_EXPORT   static  void ClassUsedTypes(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Class)& aClass,const Handle(TColStd_HSequenceOfHAsciiString)& aList,const Handle(TColStd_HSequenceOfHAsciiString)& aIncList) ;
  
  Standard_EXPORT   static  void StubClassesToExtract(const Handle(MS_MetaSchema)& aMeta,const Handle(TColStd_HSequenceOfHAsciiString)& aListOfInterClasses,WOKTools_MapOfHAsciiString& CompleteMap,WOKTools_MapOfHAsciiString& IncompleteMap,WOKTools_MapOfHAsciiString& SemiCompleteMap) ;
  
  Standard_EXPORT   static  void StubPackagesToExtract(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Interface)& Inter,WOKTools_MapOfHAsciiString& CompleteMap,WOKTools_MapOfHAsciiString& IncompleteMap,WOKTools_MapOfHAsciiString& SemiCompleteMap) ;
  
  Standard_EXPORT   static  void StubMethodsToExtract(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Interface)& Inter,const Handle(MS_HSequenceOfExternMet)& SeqOfExternMet,const Handle(MS_HSequenceOfMemberMet)& SeqOfMemberMet,WOKTools_MapOfHAsciiString& CompleteMap,WOKTools_MapOfHAsciiString& IncompleteMap,WOKTools_MapOfHAsciiString& SemiCompleteMap) ;
  
  Standard_EXPORT   static  void StubMethodTypesToExtract(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Method)& met,WOKTools_MapOfHAsciiString& CompleteMap,WOKTools_MapOfHAsciiString& IncompleteMap,WOKTools_MapOfHAsciiString& SemiCompleteMap) ;
  
  Standard_EXPORT   static  void StubMethodsTypesToExtract(const Handle(MS_MetaSchema)& aMeta,const Handle(MS_Common)& com,WOKTools_MapOfHAsciiString& CompleteMap,WOKTools_MapOfHAsciiString& IncompleteMap,WOKTools_MapOfHAsciiString& SemiCompleteMap) ;
  //! Transform an InstClass to a StdClass (for instantiation phase) <br>
//!          Don't use this method if you are not the MS's writer <br>
  Standard_EXPORT   static  Handle_MS_InstClass BuildInstClass(const Handle(MS_Class)& aClass,const Handle(TCollection_HAsciiString)& aName,const Handle(TCollection_HAsciiString)& aPackage,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqGen,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqType) ;
  //! Tranform a StdClass with generic parameter in a full StdClass <br>
//!          Don't use this method if you are not the MS's writer <br>
  Standard_EXPORT   static  Handle_MS_StdClass BuildStdClass(const Handle(MS_Class)& aClass,const Handle(TCollection_HAsciiString)& aName,const Handle(TCollection_HAsciiString)& aPackage,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqGen,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqType) ;
  //! Transform a method with generic parameter in a normal method <br>
//!          Don't use this method if you are not the MS's writer <br>
  Standard_EXPORT   static  Handle_MS_MemberMet BuildStdMethod(const Handle(MS_MemberMet)& aMethod,const Handle(MS_Class)& aClass,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqGen,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqType) ;
  
  Standard_EXPORT   static  Handle_MS_Param BuildStdParam(const Handle(MS_Param)& aParam,const Handle(MS_Method)& aMethod,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqGen,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqType) ;
  
  Standard_EXPORT   static  Handle_MS_Field BuildStdField(const Handle(MS_Field)& aField,const Handle(MS_Class)& aClass,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqGen,const Handle(TColStd_HSequenceOfHAsciiString)& aSeqType) ;
  //! to add an item only once in a sequence <br>
//!          WARNING : cursed code (use with care) <br>
  Standard_EXPORT   static  void AddOnce(const Handle(TColStd_HSequenceOfHAsciiString)& aSeq,const Handle(TCollection_HAsciiString)& Item) ;





protected:





private:




friend class MS_ExecFile;
friend class MS_MetaSchema;
friend class MS_Common;
friend class MS_Field;
friend class MS_Param;
friend class MS_ParamWithValue;
friend class MS_GlobalEntity;
friend class MS_Exec;
friend class MS_Schema;
friend class MS_Executable;
friend class MS_ExecPart;
friend class MS_Engine;
friend class MS_Component;
friend class MS_Interface;
friend class MS_Client;
friend class MS_Package;
friend class MS_Method;
friend class MS_ExternMet;
friend class MS_MemberMet;
friend class MS_Construc;
friend class MS_ClassMet;
friend class MS_InstMet;
friend class MS_Type;
friend class MS_GenType;
friend class MS_NatType;
friend class MS_Alias;
friend class MS_Pointer;
friend class MS_Enum;
friend class MS_Imported;
friend class MS_PrimType;
friend class MS_Class;
friend class MS_GenClass;
friend class MS_InstClass;
friend class MS_StdClass;
friend class MS_Error;
friend class MS_MapOfType;
friend class MS_MapOfGlobalEntity;
friend class MS_MapOfMethod;
friend class MS_SequenceOfType;
friend class MS_SequenceOfGenType;
friend class MS_SequenceOfExternMet;
friend class MS_SequenceOfMethod;
friend class MS_SequenceOfMemberMet;
friend class MS_SequenceOfField;
friend class MS_SequenceOfParam;
friend class MS_Array1OfParam;
friend class MS_SequenceOfClass;
friend class MS_SequenceOfError;
friend class MS_SequenceOfPackage;
friend class MS_SequenceOfInstClass;
friend class MS_SequenceOfGenClass;
friend class MS_SequenceOfGlobalEntity;
friend class MS_SequenceOfInterface;
friend class MS_SequenceOfSchema;
friend class MS_SequenceOfEngine;
friend class MS_SequenceOfComponent;
friend class MS_SequenceOfExecutable;
friend class MS_HSequenceOfType;
friend class MS_HSequenceOfGenType;
friend class MS_HSequenceOfExternMet;
friend class MS_HSequenceOfMethod;
friend class MS_HSequenceOfMemberMet;
friend class MS_HSequenceOfField;
friend class MS_HSequenceOfParam;
friend class MS_HArray1OfParam;
friend class MS_HSequenceOfClass;
friend class MS_HSequenceOfError;
friend class MS_HSequenceOfPackage;
friend class MS_HSequenceOfInstClass;
friend class MS_HSequenceOfGenClass;
friend class MS_HSequenceOfGlobalEntity;
friend class MS_HSequenceOfInterface;
friend class MS_HSequenceOfSchema;
friend class MS_HSequenceOfEngine;
friend class MS_HSequenceOfComponent;
friend class MS_HSequenceOfExecutable;
friend class MS_SequenceOfExecFile;
friend class MS_HSequenceOfExecFile;
friend class MS_SequenceOfExecPart;
friend class MS_HSequenceOfExecPart;
friend class MS_DataMapIteratorOfMapOfType;
friend class MS_DataMapIteratorOfMapOfGlobalEntity;
friend class MS_DataMapIteratorOfMapOfMethod;
friend class MS_SequenceNodeOfSequenceOfType;
friend class MS_SequenceNodeOfSequenceOfGenType;
friend class MS_SequenceNodeOfSequenceOfExternMet;
friend class MS_SequenceNodeOfSequenceOfMethod;
friend class MS_SequenceNodeOfSequenceOfMemberMet;
friend class MS_SequenceNodeOfSequenceOfField;
friend class MS_SequenceNodeOfSequenceOfParam;
friend class MS_SequenceNodeOfSequenceOfClass;
friend class MS_SequenceNodeOfSequenceOfError;
friend class MS_SequenceNodeOfSequenceOfPackage;
friend class MS_SequenceNodeOfSequenceOfInstClass;
friend class MS_SequenceNodeOfSequenceOfGenClass;
friend class MS_SequenceNodeOfSequenceOfGlobalEntity;
friend class MS_SequenceNodeOfSequenceOfInterface;
friend class MS_SequenceNodeOfSequenceOfSchema;
friend class MS_SequenceNodeOfSequenceOfEngine;
friend class MS_SequenceNodeOfSequenceOfComponent;
friend class MS_SequenceNodeOfSequenceOfExecutable;
friend class MS_SequenceNodeOfSequenceOfExecFile;
friend class MS_SequenceNodeOfSequenceOfExecPart;

};





// other Inline functions and methods (like "C++: function call" methods)


#endif
